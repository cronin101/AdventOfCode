{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE Strict #-}

module Lib
  ( loadInput,
    riskLevel,
    biggestBasinProduct,
  )
where

import qualified Data.Attoparsec.ByteString.Char8 as A
import qualified Data.ByteString.Char8 as BSC
import Data.Char (digitToInt)
import Data.Either (fromRight)
import Data.Function (on)
import Data.List (sortBy)
import qualified Data.Map as M
import Data.Maybe (mapMaybe)
import Data.Ord (Down (Down))
import qualified Data.Set as S

type Coordinate = (Int, Int)

type Landscape = M.Map Coordinate Int

-- >>> A.parseOnly parseRow "2199943210"
-- Right [2,1,9,9,9,4,3,2,1,0]
parseRow :: A.Parser [Int]
parseRow = map digitToInt <$> A.many1 A.digit

parseRows :: A.Parser [[Int]]
parseRows = A.sepBy1 parseRow A.endOfLine

-- >>> rowsToLandscape [[2,1,9,9,9,4,3,2,1,0],[3,9,8,7,8,9,4,9,2,1],[9,8,5,6,7,8,9,8,9,2],[8,7,6,7,8,9,6,7,8,9],[9,8,9,9,9,6,5,6,7,8]]
-- fromList [((0,0),9),((0,1),8),((0,2),9),((0,3),3),((0,4),2),((1,0),8),((1,1),7),((1,2),8),((1,3),9),((1,4),1),((2,0),9),((2,1),6),((2,2),5),((2,3),8),((2,4),9),((3,0),9),((3,1),7),((3,2),6),((3,3),7),((3,4),9),((4,0),9),((4,1),8),((4,2),7),((4,3),8),((4,4),9),((5,0),6),((5,1),9),((5,2),8),((5,3),9),((5,4),4),((6,0),5),((6,1),6),((6,2),9),((6,3),4),((6,4),3),((7,0),6),((7,1),7),((7,2),8),((7,3),9),((7,4),2),((8,0),7),((8,1),8),((8,2),9),((8,3),2),((8,4),1),((9,0),8),((9,1),9),((9,2),2),((9,3),1),((9,4),0)]
rowsToLandscape :: [[Int]] -> Landscape
rowsToLandscape rows = M.fromList $ concatMap reorderWithCoordinate $ zip ys $ map (zip [0 ..]) rows
  where
    reorderWithCoordinate (y, row) = map (\(x, val) -> ((x, y), val)) row
    ys = reverse [0 .. height -1]
    height = length rows

-- >>> adjacents (1, 2)
-- [(0,2),(2,2),(1,1),(1,3)]
-- >>> adjacents (1, 0)
-- [(0,0),(2,0),(1,1)]
adjacents :: Coordinate -> [Coordinate]
adjacents (x, y) = filter (\(x, y) -> x >= 0 && y >= 0) [(x - 1, y), (x + 1, y), (x, y -1), (x, y + 1)]

-- >>> isLowPoint (M.fromList [((0,0),9),((0,1),8),((0,2),9),((0,3),3),((0,4),2),((1,0),8),((1,1),7),((1,2),8),((1,3),9),((1,4),1),((2,0),9),((2,1),6),((2,2),5),((2,3),8),((2,4),9),((3,0),9),((3,1),7),((3,2),6),((3,3),7),((3,4),9),((4,0),9),((4,1),8),((4,2),7),((4,3),8),((4,4),9),((5,0),6),((5,1),9),((5,2),8),((5,3),9),((5,4),4),((6,0),5),((6,1),6),((6,2),9),((6,3),4),((6,4),3),((7,0),6),((7,1),7),((7,2),8),((7,3),9),((7,4),2),((8,0),7),((8,1),8),((8,2),9),((8,3),2),((8,4),1),((9,0),8),((9,1),9),((9,2),2),((9,3),1),((9,4),0)]) (6, 0)
-- True
isLowPoint :: Ord a => M.Map Coordinate a -> Coordinate -> Bool
isLowPoint landscape point = value < minimum (mapMaybe (`M.lookup` landscape) (adjacents point))
  where
    Just value = M.lookup point landscape

-- >>> lowPoints (M.fromList [((0,0),9),((0,1),8),((0,2),9),((0,3),3),((0,4),2),((1,0),8),((1,1),7),((1,2),8),((1,3),9),((1,4),1),((2,0),9),((2,1),6),((2,2),5),((2,3),8),((2,4),9),((3,0),9),((3,1),7),((3,2),6),((3,3),7),((3,4),9),((4,0),9),((4,1),8),((4,2),7),((4,3),8),((4,4),9),((5,0),6),((5,1),9),((5,2),8),((5,3),9),((5,4),4),((6,0),5),((6,1),6),((6,2),9),((6,3),4),((6,4),3),((7,0),6),((7,1),7),((7,2),8),((7,3),9),((7,4),2),((8,0),7),((8,1),8),((8,2),9),((8,3),2),((8,4),1),((9,0),8),((9,1),9),((9,2),2),((9,3),1),((9,4),0)])
-- [(1,4),(2,2),(6,0),(9,4)]
lowPoints :: Landscape -> [Coordinate]
lowPoints landscape = filter (isLowPoint landscape) $ M.keys landscape

-- >>> loadInput "example.txt"
-- fromList [((0,0),9),((0,1),8),((0,2),9),((0,3),3),((0,4),2),((1,0),8),((1,1),7),((1,2),8),((1,3),9),((1,4),1),((2,0),9),((2,1),6),((2,2),5),((2,3),8),((2,4),9),((3,0),9),((3,1),7),((3,2),6),((3,3),7),((3,4),9),((4,0),9),((4,1),8),((4,2),7),((4,3),8),((4,4),9),((5,0),6),((5,1),9),((5,2),8),((5,3),9),((5,4),4),((6,0),5),((6,1),6),((6,2),9),((6,3),4),((6,4),3),((7,0),6),((7,1),7),((7,2),8),((7,3),9),((7,4),2),((8,0),7),((8,1),8),((8,2),9),((8,3),2),((8,4),1),((9,0),8),((9,1),9),((9,2),2),((9,3),1),((9,4),0)]
loadInput :: [Char] -> IO Landscape
loadInput fileName =
  rowsToLandscape . fromRight []
    . A.parseOnly parseRows
    <$> BSC.readFile
      ("src/" ++ fileName)

-- >>> riskLevel (M.fromList [((0,0),9),((0,1),8),((0,2),9),((0,3),3),((0,4),2),((1,0),8),((1,1),7),((1,2),8),((1,3),9),((1,4),1),((2,0),9),((2,1),6),((2,2),5),((2,3),8),((2,4),9),((3,0),9),((3,1),7),((3,2),6),((3,3),7),((3,4),9),((4,0),9),((4,1),8),((4,2),7),((4,3),8),((4,4),9),((5,0),6),((5,1),9),((5,2),8),((5,3),9),((5,4),4),((6,0),5),((6,1),6),((6,2),9),((6,3),4),((6,4),3),((7,0),6),((7,1),7),((7,2),8),((7,3),9),((7,4),2),((8,0),7),((8,1),8),((8,2),9),((8,3),2),((8,4),1),((9,0),8),((9,1),9),((9,2),2),((9,3),1),((9,4),0)])
-- 15
riskLevel :: M.Map Coordinate Int -> Int
riskLevel landscape = sum $ map (+ 1) $ mapMaybe (`M.lookup` landscape) $ lowPoints landscape

-- >>> basins (M.fromList [((0,0),9),((0,1),8),((0,2),9),((0,3),3),((0,4),2),((1,0),8),((1,1),7),((1,2),8),((1,3),9),((1,4),1),((2,0),9),((2,1),6),((2,2),5),((2,3),8),((2,4),9),((3,0),9),((3,1),7),((3,2),6),((3,3),7),((3,4),9),((4,0),9),((4,1),8),((4,2),7),((4,3),8),((4,4),9),((5,0),6),((5,1),9),((5,2),8),((5,3),9),((5,4),4),((6,0),5),((6,1),6),((6,2),9),((6,3),4),((6,4),3),((7,0),6),((7,1),7),((7,2),8),((7,3),9),((7,4),2),((8,0),7),((8,1),8),((8,2),9),((8,3),2),((8,4),1),((9,0),8),((9,1),9),((9,2),2),((9,3),1),((9,4),0)])
-- [fromList [(0,3),(0,4),(1,4)],fromList [(0,1),(1,0),(1,1),(1,2),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(5,2)],fromList [(5,0),(6,0),(6,1),(7,0),(7,1),(7,2),(8,0),(8,1),(9,0)],fromList [(5,4),(6,3),(6,4),(7,4),(8,3),(8,4),(9,2),(9,3),(9,4)]]
basins :: Landscape -> [S.Set Coordinate]
basins landscape = map (\point -> S.filter ((/= Just 9) . (`M.lookup` landscape)) $ graphSearch [point] S.empty) $ lowPoints landscape
  where
    graphSearch :: [Coordinate] -> S.Set Coordinate -> S.Set Coordinate
    graphSearch [] visited = visited
    graphSearch (x : xs) visited = case M.lookup x landscape of
      Just 9 -> graphSearch xs (S.insert x visited)
      _ -> graphSearch (filter (not . (`S.member` visited)) $ filter (`S.member` M.keysSet landscape) (xs ++ adjacents x)) (S.insert x visited)

-- >>> biggestBasins (M.fromList [((0,0),9),((0,1),8),((0,2),9),((0,3),3),((0,4),2),((1,0),8),((1,1),7),((1,2),8),((1,3),9),((1,4),1),((2,0),9),((2,1),6),((2,2),5),((2,3),8),((2,4),9),((3,0),9),((3,1),7),((3,2),6),((3,3),7),((3,4),9),((4,0),9),((4,1),8),((4,2),7),((4,3),8),((4,4),9),((5,0),6),((5,1),9),((5,2),8),((5,3),9),((5,4),4),((6,0),5),((6,1),6),((6,2),9),((6,3),4),((6,4),3),((7,0),6),((7,1),7),((7,2),8),((7,3),9),((7,4),2),((8,0),7),((8,1),8),((8,2),9),((8,3),2),((8,4),1),((9,0),8),((9,1),9),((9,2),2),((9,3),1),((9,4),0)])
-- [fromList [(0,1),(1,0),(1,1),(1,2),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(5,2)],fromList [(5,0),(6,0),(6,1),(7,0),(7,1),(7,2),(8,0),(8,1),(9,0)],fromList [(5,4),(6,3),(6,4),(7,4),(8,3),(8,4),(9,2),(9,3),(9,4)]]
biggestBasins :: Landscape -> [S.Set Coordinate]
biggestBasins = take 3 . sortBy (compare `on` (Down . S.size)) . basins

-- >>> biggestBasinProduct (M.fromList [((0,0),9),((0,1),8),((0,2),9),((0,3),3),((0,4),2),((1,0),8),((1,1),7),((1,2),8),((1,3),9),((1,4),1),((2,0),9),((2,1),6),((2,2),5),((2,3),8),((2,4),9),((3,0),9),((3,1),7),((3,2),6),((3,3),7),((3,4),9),((4,0),9),((4,1),8),((4,2),7),((4,3),8),((4,4),9),((5,0),6),((5,1),9),((5,2),8),((5,3),9),((5,4),4),((6,0),5),((6,1),6),((6,2),9),((6,3),4),((6,4),3),((7,0),6),((7,1),7),((7,2),8),((7,3),9),((7,4),2),((8,0),7),((8,1),8),((8,2),9),((8,3),2),((8,4),1),((9,0),8),((9,1),9),((9,2),2),((9,3),1),((9,4),0)])
-- 1134
biggestBasinProduct :: Landscape -> Int
biggestBasinProduct = product . map S.size . biggestBasins
